/********************************************************************************/
树的基本概念：
节点的度：子树的个树
树的度：所有节点度中的最大植
叶子节点：度为0的节点
层数：根节点在第1层，根节点的子节点在第2层，以此类推
节点的深度：从根节点到当前节点的唯一路径上的节点总数
节点的高度：从当前节点到最远叶子节点的路径上的节点总数
树的深度：所有节点深度中的最大值
树的高度：所有节点高度中的最大值
树的深度等于树的高度

有序树：树中的人以节点之间有顺序关系
无序树：树中的任意子节点之间没有顺序关系

/********************************************************************************/
二叉树
定义：每个节点的度最大为2（最多拥有2颗子树）
特点：左子树和右子树是有顺序的
     即使某个节点只有一棵子树，也要区分左右子树
     二叉树是有序树

真二叉树：
定义：所有节点的度要么为0,要么为2

满二叉树：
定义：所有节点的度要么为0,要么为2。且所有的叶子节点都在最后一层
     在同样高度的二叉树中，满二叉树的叶子节点数量最多，总节点数量最多
     满二叉树一定是真二叉树，真二叉树不一定是满二叉树

完全二叉树：
定义：叶子节点只会出现在最后2曾，且最后1层的叶子节点都靠左对齐
特点：完全二叉树从根节点至倒数第2层是一棵满二叉树
     满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树
     同样节点数量的二叉树，完全二叉树的高度最小
     
     假设完全二叉树的高度为h（h>=1）,则至少有2^(h - 1)个节点（2^0 + 2^1 + 2^2 + ... + 2^(h-2) + 1）
     假设完全二叉树的高度为h（h>=1）,则最多有2^h - 1个节点（2^0 + 2^1 + 2^2 + ... + 2^(h-1），满二叉树）

     总节点数为n：2^(h-1) =< n < 2^h
                h-1 <= log2(n) < h  ==> h = log2(n)向下取整 + 1
                floor(向下取整)
                ceiling(向上取整数)

     面试题：如果一棵完全二叉树有768个结点，求叶子节点的个数
     求解过程：n = n0 + n1 + n2  && n0 = n2 + 1
             ==> n = 2n0 + n1 - 1
             完全二叉树的n1要么为0,要么为1
             n1为1时： n = 2n0         ==> n为偶数  n0 = n / 2   
             n1为0时： n = 2n0 - 1     ==> n为奇数  n0 = (n + 1) / 2

             统一公式：n0 = int((n + 1) / 2)

     前序遍历：树状结构展示
     中序遍历：二叉搜索树的中序遍历按升序或者降序处理节点
     后续遍历：适用于一些先子后父的操作
     层序遍历：计算二叉树的高度
             判断一棵树是否为完全二叉树

     根据遍历结果重构二叉树
     1.以下结果可以保证重构出唯一的一棵二叉树
       前序遍历 + 中序遍历
       后序遍历 + 中序遍历
     2.前序遍历 + 后序遍历
       如果它是一棵真二叉树，结果是唯一的
       不然结果不唯一

     前驱节点：中序遍历时的前一个节点

/********************************************************************************/
二叉搜索树：二叉搜索树是二叉树的一种，是应用非常广泛的一种二叉树，英文简称为BST
          又称为二叉查找树、二叉排序树
特点：任意一个节点的值都大于其左子树所有节点的值
     任意一个节点的值都小于其右子树所有节点的值
     它的左右子树也是一棵二叉搜索树
     二叉搜索树所存储的元素必须具备可比较性，且不允许为空
     
     二叉搜索树接口
     /*
     int size() 
     bool isEmpty()
     void clear()
     void add(E element)
     void remove(E element)
     bool contains(E element)
     */

/********************************************************************************/
二叉搜索树添加、删除节点时，都有可能会导致二叉搜索树退化成链表
有没有办法防止二叉搜索树退化成链表（让添加、删除、搜索的复杂度维持在O(logn)）

平衡：当节点数量固定时，左右子树的高度越接近就越平衡（高度越低）

如何改进二叉搜索树
首先，节点的添加、删除顺序是无法限制的，可以认为是随即的
所以，改进的方案是：在节点的添加、删除操作之后，想办法让二叉搜索树恢复平衡（减少树的高度）
                 如果接着继续调整节点的位置，完全可以达到理想平衡，但是付出的代价可能会比较大
比较合理的改进方案：用尽量少的调整次数达到适度平衡即可
一颗适度平衡的二叉搜索树，可以称之为：平衡二叉搜索树

经典常见的平衡二叉搜索树有:AVL树（windows NT 内核中广泛使用） 红黑树(C++ STL, linux的进程调度)
AVL树，红黑树称为自平衡二叉搜索树

/********************************************************************************/
AVL树：
平衡因子（Balance Factor）：某节点的左右子树的高度差
AVL树每个节点的平衡因子只可能是1、0、-1（绝对值<=1, 如果超过1, 称为失衡）
每个节点的左右子树高度差不超过1
搜索、添加、删除的时间复杂度是O(logn)
