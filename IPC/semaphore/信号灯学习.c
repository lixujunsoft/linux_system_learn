/*
1.什么是信号灯
  信号灯用来实现同步，用于多线程，多进程之间同步共享资源（临界资源）。
2.PV原语：信号灯使用PV原语
  PV原语通过操作信号量来处理进程间的同步与互斥的问题。其核心就是一段不可分割不可中断的程序
  变量类型有两种实现方式：
    a.变量类型的取值必须大于或等于0。0表示当前已没有空闲资源，而正数表示当前空闲资源的数量
    b.变量类型的取值可正可负，负数的绝对值表示正等待进入临界区的进程个数

  P原语（为阻塞原语，负责把当前进程由运行状态转换为阻塞状态，直到另外一个进程唤醒它，操作为：申请一个空闲资源(把信号量减1)，若成功，则退出；若失败，则该进程被阻塞）：
    sem减1
    sem减1后仍大于或等于零，则进程继续执行
    若sem减1后小于零，则该进程被阻塞后进入与该信号相对应的队列中，然后转进程调度。
  V原语（为唤醒原语，负责把一个被阻塞的进程唤醒，它有一个参数表，存放着等待被唤醒的进程信息。操作为：释放一个被占用的资源(把信号量加1)，如果发现有被阻塞的进程，则选择一个唤醒之）：
    sem加1
    若相加结果大于零，则进程继续执行。
    若相加结果小于或等于零，则从该信号的等待队列中唤醒一等待进程，然后再返回原进程继续执行或转进程调度。
3.具体PV原语对信号量的操作可以分为三种情况：
    a.把信号量视为一个加锁标志位，实现对一个共享变量的互斥访问。
        实现过程：
        P(mutex); // mutex的初始值为1 访问该共享数据;
        V(mutex);
        非临界区;
    b.把信号量视为是某种类型的共享资源的剩余个数，实现对一类共享资源的访问。
        实现过程：
        P(resource); // resource的初始值为该资源的个数N 使用该资源；
        V(resource);
        非临界区;
　　 c.把信号量作为进程间的同步工具
        实现过程： 
        临界区C1;
        P(S);
        V(S);
        临界区C2;
4.信号灯分类
    按信号灯实现原理，信号灯分两种，一种是有名信号灯，一种是基于内存的信号灯。
    有名信号灯，是根据外部名字标识，通常指代文件系统中的某个文件。而基于内存的信号灯，它主要是把信号灯放入内存的。
    基于内存的信号灯，同步多线程时，可以放到该多线程所属进程空间里；如果是同步多进程，那就需要把信号灯放入到共享内存中（方便多个进程访问）。
    按实现方式，信号灯分为POSIX信号灯和System V信号灯，System V信号灯是由内核维护的，Posix信号灯是由文件系统中的路径名对应的名字来标识的。在目前的Linux中，System V使用更为广泛，POSIX一般是在更老的系统中使用。
5.进程在信号灯上的几种操作
    a.创建一个信号灯。还要求调用者指定初始值，对二值来说通常是1。
    b.等待一个信号灯。测试信号灯的值，如果<=0则等待，否则将其减1。注：测试其值并减1必须作为一个原子操作。
    c.挂出一个信号灯。将信号灯的值加1。挂出操作也必须是原子的。
    d.获取信号灯状态。
    二值信号灯可用于互斥目的。除了可以象互斥锁那样使用外，信号灯还有一个互斥锁没有提供的特性：互斥锁必须总是由锁住他的线程解锁，信号灯的挂出却不必由执行过它的等待操作的同一线程执行。比如生产者消费者问题是生产者和消费者互相唤醒的。
    信号灯有一个与之关联的值，挂出一个信号即使当前没有线程在等待该信号也没关系，与之相反的是，pthread_cond_signal如果当时没有任何线程阻塞在pthread_cond_wait中，则信号丢失。


*/